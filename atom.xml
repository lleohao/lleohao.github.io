<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lleo</title>
  
  <subtitle>Lleohao`s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lleohao.github.io/"/>
  <updated>2020-11-24T06:07:16.912Z</updated>
  <id>https://lleohao.github.io/</id>
  
  <author>
    <name>Lleo hao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Web 页面打开 APP 方式总结</title>
    <link href="https://lleohao.github.io/2020/11/12/Web%20%E9%A1%B5%E9%9D%A2%E8%B0%83%E7%94%A8%20APP%20%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>https://lleohao.github.io/2020/11/12/Web 页面调用 APP 方式总结/</id>
    <published>2020-11-12T09:47:15.000Z</published>
    <updated>2020-11-24T06:07:16.912Z</updated>
    
    <content type="html"><![CDATA[<h2 id="🌐-通用方案-URL-Scheme"><a href="#🌐-通用方案-URL-Scheme" class="headerlink" title="🌐 通用方案 URL Scheme"></a>🌐 通用方案 URL Scheme</h2><h3 id="学术派，了解什么是-URL-Scheme"><a href="#学术派，了解什么是-URL-Scheme" class="headerlink" title="学术派，了解什么是 URL Scheme"></a>学术派，了解什么是 URL Scheme</h3><p>URL（Uniform Resource Locator）是指定在互联网上可以找到资源的位置的文本字符串</p><p>通常可以分成三个部分：方案（Scheme）、主机（host）、路径（path）</p><p><img src="https://blogimages-10011410.cos.ap-shanghai.myqcloud.com/images/Web%20%E9%A1%B5%E9%9D%A2%E8%B0%83%E7%94%A8%20APP%20%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/Untitled.png" alt="HTTP 权威指南 - URL"></p><p>当应用程序得到一个 URL 时，通过对它的解析，就知道去哪个地方、什么位置获取资源，同时用哪种方式去处理这个资源</p><p>例如当浏览器处理 <code>https://lleohao.github.io/archives/</code> 这个 URL 时，它就会以 <code>http</code> 协议的方式去<code>lleohao.github.io</code> 这个域名所对应的主机下找寻 <code>/archives/</code> 位置的文档</p><a id="more"></a><p>互联网上的资源不仅仅指的是网页、图片、视频等文件，我们的 App 和 App 中的功能同样也可以视作一个资源</p><p>当 APP 在用户的设备上安装时，其可以在系统注册某个协议，如知乎所注册的就是 <code>zhihu</code></p><p>用户访问 <code>zhihu://articles/{id}</code> 这个 URL 时就可以访问到知乎对应的文章页面</p><h3 id="Web-页面如何调用-URL-Scheme"><a href="#Web-页面如何调用-URL-Scheme" class="headerlink" title="Web 页面如何调用 URL Scheme"></a>Web 页面如何调用 URL Scheme</h3><blockquote><p><a href="https://lleohao-blog-demo.netlify.app/pages/url-scheme" target="_blank" rel="noopener">URL Scheme 测试网页</a></p></blockquote><p><code>URL Scheme</code> 可以视作普通的 URL 链接，<strong>直接按照链接方式来使用</strong></p><ol><li><p>使用 <code>a</code> 标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"zhihu://articles/296580539"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>设置 <code>location.href</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">openApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  location.href = <span class="string">"zhihu://articles/296580539"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>window.open</code> 会怎样？</p><p>🛑 不要使用 <code>window.open</code> ，IOS 可以正常的开启 App，Android 上可能无法冷启动 App （oppo 浏览器）</p></li></ol><h3 id="URL-Scheme-的缺陷"><a href="#URL-Scheme-的缺陷" class="headerlink" title="URL Scheme 的缺陷"></a>URL Scheme 的缺陷</h3><ul><li><p>打开 App 前会有二次确弹窗，体验不够流畅</p><p><img src="https://blogimages-10011410.cos.ap-shanghai.myqcloud.com/images/Web%20%E9%A1%B5%E9%9D%A2%E8%B0%83%E7%94%A8%20APP%20%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/Untitled%201.png" alt="IOS 二次提示弹窗"></p></li><li><p>无法判断拉端是否成功</p><ul><li><p>已安装应用，弹出二次提示，但是无法获取用户最终点击了按钮</p></li><li><p>未安装应用</p><ul><li><p>IOS 提示网址无效</p><p><img src="https://blogimages-10011410.cos.ap-shanghai.myqcloud.com/images/Web%20%E9%A1%B5%E9%9D%A2%E8%B0%83%E7%94%A8%20APP%20%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/Untitled%202.png" alt="IOS 显示网址无效"></p></li><li><p>Android 页面无任何反应</p></li></ul></li></ul></li><li><p>存在安全风险</p><p>由于 URL Scheme 的不唯一性，存在恶意的 App 伪造其它 App 的 URL Scheme，存在安全风险</p></li></ul><p>总结来说，由于二次确认弹窗的存在，造成了体验的分割，不够流畅</p><p>其次是无法获取弹窗的响应状态（用户是否确认、取消）及未安装 App 状态，无法针对用户的响应作出对应的处理</p><h2 id="👏-体验更好的方案"><a href="#👏-体验更好的方案" class="headerlink" title="👏 体验更好的方案"></a>👏 体验更好的方案</h2><p>针对 URL Scheme 存在的问题，IOS （Universal Link）和 Android （Android Applink）都给出了对应的解决方案</p><p>为描述的方便，下文中的 <code>Universal Link</code> 指的是 IOS 下的 <code>Universal Link</code> 和 Android 下的 <code>Android Applink</code></p><h3 id="如何理解-Universal-Link"><a href="#如何理解-Universal-Link" class="headerlink" title="如何理解 Universal Link"></a>如何理解 Universal Link</h3><p>简单来说，可以将 <code>Universal Link</code> 理解成被 App 注册的 <code>https</code> 链接</p><p>当 App 安装时，系统会去注册的 <code>https</code> 链接的域名下检查是否存在相关的验证的文件，如果存在，那么以后浏览器在处理该域名的下的链接时就会调用对应的 App 的做处理</p><p><img src="https://blogimages-10011410.cos.ap-shanghai.myqcloud.com/images/Web%20%E9%A1%B5%E9%9D%A2%E8%B0%83%E7%94%A8%20APP%20%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/mermaid-diagram-20201120102927.png" alt="Universal Link 工作流程"></p><h3 id="Universal-Link-优点"><a href="#Universal-Link-优点" class="headerlink" title="Universal Link 优点"></a>Universal Link 优点</h3><ul><li><strong>体验好：</strong>没有二次的弹窗提示，可以流畅的开启客户端；在没有安装 App 时，也可以向正常的链接一样工作，不影响用户的浏览</li><li><strong>安全：</strong>需要在 App 上配置域名，且在安装后系统验证 <code>Universal Link</code> 需要验证对应域名下是否存在说明文件，保证只有该 App 的管理员才能做此操作</li><li><strong>突破封锁：</strong>IOS 下 *<strong>*<code>Universal Link</code> 可以突破微信限制在其 <code>Webview</code> 中拉端的限制；</strong>Android 未测试**</li></ul><h2 id="💯-实践案例"><a href="#💯-实践案例" class="headerlink" title="💯 实践案例"></a>💯 实践案例</h2><blockquote><p>以知乎的首页的 “打开 APP” 的功能进行分析</p></blockquote><h3 id="IOS"><a href="#IOS" class="headerlink" title="IOS"></a>IOS</h3><p>由于 IOS 上对于的 <code>Universal Link</code> 的处理<strong>需要在跨域时才能生效</strong>（未跨域时按照正常的链接处理），所以知乎以 <code>[https://oia.zhihu.com](https://oia.zhihu.com)</code> 作为打开 App 的目标链接</p><p><img src="https://blogimages-10011410.cos.ap-shanghai.myqcloud.com/images/Web%20%E9%A1%B5%E9%9D%A2%E8%B0%83%E7%94%A8%20APP%20%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/mermaid-diagram-20201122202042.png" alt="IOS 知乎拉端流程"></p><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><p>Android 上没有跨域的限制，可以访问主域名下的地址</p><p><img src="https://blogimages-10011410.cos.ap-shanghai.myqcloud.com/images/Web%20%E9%A1%B5%E9%9D%A2%E8%B0%83%E7%94%A8%20APP%20%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/mermaid-diagram-20201122202042.png" alt="Android 知乎拉端流程"></p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://developer.apple.com/ios/universal-links/" target="_blank" rel="noopener">Universal Links - Apple Developer</a></p><p><a href="https://developer.android.com/training/app-links" target="_blank" rel="noopener">Android Applinks</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;🌐-通用方案-URL-Scheme&quot;&gt;&lt;a href=&quot;#🌐-通用方案-URL-Scheme&quot; class=&quot;headerlink&quot; title=&quot;🌐 通用方案 URL Scheme&quot;&gt;&lt;/a&gt;🌐 通用方案 URL Scheme&lt;/h2&gt;&lt;h3 id=&quot;学术派，了解什么是-URL-Scheme&quot;&gt;&lt;a href=&quot;#学术派，了解什么是-URL-Scheme&quot; class=&quot;headerlink&quot; title=&quot;学术派，了解什么是 URL Scheme&quot;&gt;&lt;/a&gt;学术派，了解什么是 URL Scheme&lt;/h3&gt;&lt;p&gt;URL（Uniform Resource Locator）是指定在互联网上可以找到资源的位置的文本字符串&lt;/p&gt;&lt;p&gt;通常可以分成三个部分：方案（Scheme）、主机（host）、路径（path）&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://blogimages-10011410.cos.ap-shanghai.myqcloud.com/images/Web%20%E9%A1%B5%E9%9D%A2%E8%B0%83%E7%94%A8%20APP%20%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/Untitled.png&quot; alt=&quot;HTTP 权威指南 - URL&quot;&gt;&lt;/p&gt;&lt;p&gt;当应用程序得到一个 URL 时，通过对它的解析，就知道去哪个地方、什么位置获取资源，同时用哪种方式去处理这个资源&lt;/p&gt;&lt;p&gt;例如当浏览器处理 &lt;code&gt;https://lleohao.github.io/archives/&lt;/code&gt; 这个 URL 时，它就会以 &lt;code&gt;http&lt;/code&gt; 协议的方式去&lt;code&gt;lleohao.github.io&lt;/code&gt; 这个域名所对应的主机下找寻 &lt;code&gt;/archives/&lt;/code&gt; 位置的文档&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Web" scheme="https://lleohao.github.io/tags/Web/"/>
    
      <category term="H5" scheme="https://lleohao.github.io/tags/H5/"/>
    
      <category term="Android" scheme="https://lleohao.github.io/tags/Android/"/>
    
      <category term="IOS" scheme="https://lleohao.github.io/tags/IOS/"/>
    
      <category term="iPhone" scheme="https://lleohao.github.io/tags/iPhone/"/>
    
      <category term="App" scheme="https://lleohao.github.io/tags/App/"/>
    
  </entry>
  
  <entry>
    <title>使用 travis 发布 npm 包</title>
    <link href="https://lleohao.github.io/2020/06/29/%E4%BD%BF%E7%94%A8-travis-%E5%8F%91%E5%B8%83-npm-%E5%8C%85/"/>
    <id>https://lleohao.github.io/2020/06/29/使用-travis-发布-npm-包/</id>
    <published>2020-06-29T07:11:20.000Z</published>
    <updated>2020-11-24T06:07:16.916Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL:DR"></a>TL:DR</h3><blockquote><p>相关链接</p><ul><li><a href="https://github.com/travis-ci/travis.rb#readme" target="_blank" rel="noopener">travis-cli 文档</a></li><li><a href="https://docs.travis-ci.com/user/deployment/npm/" target="_blank" rel="noopener">Travis NPM Releasing 文档</a></li></ul></blockquote><ol><li><p>获取需要的 <code>Token</code></p><ul><li><a href="https://github.com/settings/tokens" target="_blank" rel="noopener">Github Access Token</a></li><li><a href="https://docs.travis-ci.com/user/deployment/npm/#npm-auth-token" target="_blank" rel="noopener">NPM auth token 获取方式</a> 在 <code>travis</code> 中也称做 <code>api_key</code></li></ul></li><li><p>登录 <code>Travis cli</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">travis login --com --github-token &lt;GITHUB_ACCESS_TOKEN&gt;</span><br></pre></td></tr></table></figure></li><li><p>配置基础 <code>.travis.yml</code>，使用 <code>travis setup npm</code> 的前置依赖</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="number">14</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>travis setup npm</code> 命令补充配置</p></li></ol><a id="more"></a><h3 id="如何保护自己的私密信息"><a href="#如何保护自己的私密信息" class="headerlink" title="如何保护自己的私密信息"></a>如何保护自己的私密信息</h3><p>执行 <code>npm publish</code> 时需要 <code>npm</code> 的 <code>auth token</code> ，而这个信息显然是不适合中显式的放在 <code>.travis.yml</code> 中</p><p>这时可以通过 <code>travis encrypt</code> 命令来加密信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">travis encrypt &lt;TOKEN&gt; --add &lt;CONFIG.PATH&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># YOUR_AUTH_TOKEN 需要加密的TOKEN</span></span><br><span class="line"><span class="comment"># CONFIG.PATH 在 yml 文件（可理解为对象）中的位置，如 `deploy.api_key` 代表是 `deploy` 下的 `api_key` 属性</span></span><br></pre></td></tr></table></figure><p><strong>这同样也适合其它需要加密的信息，如你的数据库链接信息</strong></p><h3 id="指定发布的时机"><a href="#指定发布的时机" class="headerlink" title="指定发布的时机"></a>指定发布的时机</h3><ol><li><p>指定分支发布</p><p><strong>特定分支</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line"><span class="attr">branch:</span> <span class="string">production</span></span><br></pre></td></tr></table></figure><p><strong>所有分支</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line"><span class="attr">all_branch:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>存在新的 <code>tag</code> 时发布</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line"><span class="attr">tags:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>记得使用 <code>git push --tags</code> 推送 <code>tag</code> 到 <code>github</code> 上</strong></p></li></ol><h3 id="疑难问题解答"><a href="#疑难问题解答" class="headerlink" title="疑难问题解答"></a>疑难问题解答</h3><ol><li><p><code>travis login</code> 碰到 <code>has not granted Travis CI the required permissions, please log in via travis-ci.org</code> 怎么处理？</p><p>如果你使用的是 <code>travis-ci.org</code> 的话，会碰到这个问题，解决方案是迁移到 <code>travis-org.com</code>。同时使用 <code>travis login --com</code> 命令登录</p><p>补充一个相关问题的链接 <a href="https://github.com/dwyl/learn-travis/issues/60#issuecomment-620692873" target="_blank" rel="noopener">travis-ci.org vs travis-ci.com?</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;TL-DR&quot;&gt;&lt;a href=&quot;#TL-DR&quot; class=&quot;headerlink&quot; title=&quot;TL:DR&quot;&gt;&lt;/a&gt;TL:DR&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;相关链接&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/travis-ci/travis.rb#readme&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;travis-cli 文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.travis-ci.com/user/deployment/npm/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Travis NPM Releasing 文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;获取需要的 &lt;code&gt;Token&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/settings/tokens&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github Access Token&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.travis-ci.com/user/deployment/npm/#npm-auth-token&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NPM auth token 获取方式&lt;/a&gt; 在 &lt;code&gt;travis&lt;/code&gt; 中也称做 &lt;code&gt;api_key&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;登录 &lt;code&gt;Travis cli&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;travis login --com --github-token &amp;lt;GITHUB_ACCESS_TOKEN&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置基础 &lt;code&gt;.travis.yml&lt;/code&gt;，使用 &lt;code&gt;travis setup npm&lt;/code&gt; 的前置依赖&lt;/p&gt;
&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;language:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;node_js&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;node_js:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;  -&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;14&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用 &lt;code&gt;travis setup npm&lt;/code&gt; 命令补充配置&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="travis" scheme="https://lleohao.github.io/tags/travis/"/>
    
      <category term="npm" scheme="https://lleohao.github.io/tags/npm/"/>
    
      <category term="ci" scheme="https://lleohao.github.io/tags/ci/"/>
    
      <category term="github" scheme="https://lleohao.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>使用 pointer-events 解决 svg 元素路径内不触发鼠标事件</title>
    <link href="https://lleohao.github.io/2019/10/12/%E4%BD%BF%E7%94%A8-pointer-events-%E8%A7%A3%E5%86%B3-svg-%E5%85%83%E7%B4%A0%E8%B7%AF%E5%BE%84%E5%86%85%E4%B8%8D%E8%A7%A6%E5%8F%91%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6/"/>
    <id>https://lleohao.github.io/2019/10/12/使用-pointer-events-解决-svg-元素路径内不触发鼠标事件/</id>
    <published>2019-10-12T03:25:13.000Z</published>
    <updated>2020-11-24T06:07:16.916Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><iframe src="https://codesandbox.io/embed/point-events-shuxingxiangjie-2f8tb?fontsize=14" title="point-events 属性详解" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题背景&quot;&gt;&lt;a href=&quot;#问题背景&quot; class=&quot;headerlink&quot; title=&quot;问题背景&quot;&gt;&lt;/a&gt;问题背景&lt;/h2&gt;&lt;iframe src=&quot;https://codesandbox.io/embed/point-events-shuxingxia
      
    
    </summary>
    
    
      <category term="踩坑指北" scheme="https://lleohao.github.io/categories/%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8C%97/"/>
    
    
      <category term="css" scheme="https://lleohao.github.io/tags/css/"/>
    
      <category term="svg" scheme="https://lleohao.github.io/tags/svg/"/>
    
      <category term="前端" scheme="https://lleohao.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>如何在 vscode 中共享团队间的项目配置和插件配置</title>
    <link href="https://lleohao.github.io/2019/09/23/%E5%A6%82%E4%BD%95%E5%9C%A8-vscode-%E4%B8%AD%E5%85%B1%E4%BA%AB%E5%9B%A2%E9%98%9F%E9%97%B4%E7%9A%84%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E5%92%8C%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE/"/>
    <id>https://lleohao.github.io/2019/09/23/如何在-vscode-中共享团队间的项目配置和插件配置/</id>
    <published>2019-09-23T11:37:14.000Z</published>
    <updated>2020-11-24T06:07:16.916Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近团队中开启了许多新的前端项目，也有新的同事加入了团队中</p><p>项目多了，如何确保所有成员都有一致的开发环境就是一个麻烦的问题，本文将介绍如何解决这个问题</p></blockquote><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p><code>vscode</code> 中的配置信息分为<strong>用户配置</strong>和<strong>项目配置</strong>两种</p><ul><li>用户配置在所有打开的 <code>vscode</code> 中生效</li><li>项目配置存放于项目所在位置的 <code>.vscode</code> 文件夹中，当项目在 <code>vscode</code> 中打开时，针对打开的窗口生效</li></ul><p>如果同时存在项目配置和用户配置，将以项目配置优先</p><p>我们可以通过项目配置文件来共享 <code>vscode</code> 配置，达到统一开发环境的目的</p><h2 id="同步插件"><a href="#同步插件" class="headerlink" title="同步插件"></a>同步插件</h2><p>插件文件 <code>extensions.json</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 示例代码</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"recommendations"</span>: [</span><br><span class="line">    <span class="string">"dbaeumer.vscode-eslint"</span>,</span><br><span class="line">    <span class="string">"esbenp.prettier-vscode"</span>,</span><br><span class="line">    <span class="string">"octref.vetur"</span>,</span><br><span class="line">    <span class="string">"formulahendry.auto-close-tag"</span>,</span><br><span class="line">    <span class="string">"formulahendry.auto-rename-tag"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>插件名称</p><p><img src="img-1.png" alt="以 &lt;插件开发者&gt;.&lt;插件名称&gt; 来确定具体的插件"></p><p>设置完成后，可以在 <code>vscode</code> 插件配置中一键安装上面设置的插件</p><p><img src="img-2.png" alt="@recommended 搜索推荐的插件"></p><h2 id="同步配置"><a href="#同步配置" class="headerlink" title="同步配置"></a>同步配置</h2><p>配置文件 <code>settings.json</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"eslint.autoFixOnSave"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件的是自动生效的</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近团队中开启了许多新的前端项目，也有新的同事加入了团队中&lt;/p&gt;
&lt;p&gt;项目多了，如何确保所有成员都有一致的开发环境就是一个麻烦的问题，本文将介绍如何解决这个问题&lt;/p&gt;
&lt;/blockquote&gt;&lt;h2 id=&quot;背景知识&quot;&gt;&lt;a href=&quot;#背景知识&quot; class=&quot;headerlink&quot; title=&quot;背景知识&quot;&gt;&lt;/a&gt;背景知识&lt;/h2&gt;&lt;p&gt;&lt;code&gt;vscode&lt;/code&gt; 中的配置信息分为&lt;strong&gt;用户配置&lt;/strong&gt;和&lt;strong&gt;项目配置&lt;/strong&gt;两种&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;用户配置在所有打开的 &lt;code&gt;vscode&lt;/code&gt; 中生效&lt;/li&gt;
&lt;li&gt;项目配置存放于项目所在位置的 &lt;code&gt;.vscode&lt;/code&gt; 文件夹中，当项目在 &lt;code&gt;vscode&lt;/code&gt; 中打开时，针对打开的窗口生效&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果同时存在项目配置和用户配置，将以项目配置优先&lt;/p&gt;&lt;p&gt;我们可以通过项目配置文件来共享 &lt;code&gt;vscode&lt;/code&gt; 配置，达到统一开发环境的目的&lt;/p&gt;&lt;h2 id=&quot;同步插件&quot;&gt;&lt;a href=&quot;#同步插件&quot; class=&quot;headerlink&quot; title=&quot;同步插件&quot;&gt;&lt;/a&gt;同步插件&lt;/h2&gt;&lt;p&gt;插件文件 &lt;code&gt;extensions.json&lt;/code&gt;&lt;/p&gt;&lt;figure class=&quot;highlight json&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 示例代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;&quot;recommendations&quot;&lt;/span&gt;: [&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;dbaeumer.vscode-eslint&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;esbenp.prettier-vscode&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;octref.vetur&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;formulahendry.auto-close-tag&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;formulahendry.auto-rename-tag&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="开发技巧" scheme="https://lleohao.github.io/tags/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>前端框架中 “类mixin” 模式的思考</title>
    <link href="https://lleohao.github.io/2018/12/28/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E4%B8%AD%20%E2%80%9C%E7%B1%BBmixin%E2%80%9D%20%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%80%9D%E8%80%83%20/"/>
    <id>https://lleohao.github.io/2018/12/28/前端框架中 “类mixin” 模式的思考 /</id>
    <published>2018-12-28T09:22:35.000Z</published>
    <updated>2020-11-24T06:07:16.916Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“类 mixin” 指的是 Vue 中的 mixin，Regular 中的 implement</p></blockquote><h2 id="使用-Mixin-的目的"><a href="#使用-Mixin-的目的" class="headerlink" title="使用 Mixin 的目的"></a>使用 Mixin 的目的</h2><h3 id="首先我们需要知道为什么会有-mixin-的存在？"><a href="#首先我们需要知道为什么会有-mixin-的存在？" class="headerlink" title="首先我们需要知道为什么会有 mixin 的存在？"></a>首先我们需要知道为什么会有 <code>mixin</code> 的存在？</h3><ol><li><p>为了扩展对象（组件）的功能</p><p>扩展对象功能的需求是很容易的理解的。比如业务开发时会碰到跨模块传递消息的需求，常用的方法是使用 “发布-订阅模式” 来创建一个全局的<code>EventEmitter</code>。不使用 <code>mixin</code> 时的使用方法如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// global/eventEmitter</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">    on(eventName, handle) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    emit(eventName) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ComponentA</span></span><br><span class="line"><span class="keyword">import</span> EventEmitter <span class="keyword">from</span> <span class="string">'global/eventEmitter'</span>; <span class="comment">// 全局的 EventEmitter 对象</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComponentA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        EventEmitter.on(<span class="string">'event'</span>, () =&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ComponentB</span></span><br><span class="line"><span class="keyword">import</span> EventEmitter <span class="keyword">from</span> <span class="string">'global/eventEmitter'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComponentB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        EventEmitter.emit(<span class="string">'event'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要在不同的组件中引入 <code>EventEmitter</code> 来使用它</p><p>如果使用 <code>mixin</code> 的话，我们可以这样做</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eventEmitter mixin</span></span><br><span class="line"><span class="keyword">import</span> EventEmitter <span class="keyword">from</span> <span class="string">'global/eventEmitter'</span>; <span class="comment">// 全局的 EventEmitter 对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> eventEmitterMixin = &#123;</span><br><span class="line">    on: <span class="function">(<span class="params">eventName, handle</span>) =&gt;</span> &#123;EventEmitter.on(eventName, handle)&#125;,</span><br><span class="line">    fire: <span class="function"><span class="params">()</span> =&gt;</span> &#123;EventEmitter.emit(eventName)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Root Component</span></span><br><span class="line">Component.mixin(eventEmitterMixin);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ComponentA</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComponentA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.on(<span class="string">'event'</span>, () =&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ComponentB</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComponentB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.emit(<span class="string">'event'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样通过<code>mixin</code>来扩展了组件的功能，是每个组件都可以方便的使用 <code>EventEmitter</code> 的功能</p></li><li><p>为了复用代码</p><p>软件开发中的 <code>DRY</code> 原则还是有必要遵守的。过多的重复代码会导致维护上的麻烦，通过 <code>mixin</code> ，我们可以在不同的对象上使用同一份代码来完成相同的功能，减轻我们维护的压力。</p></li></ol><a id="more"></a><h3 id="复用-VS-扩展"><a href="#复用-VS-扩展" class="headerlink" title="复用 VS 扩展"></a>复用 VS 扩展</h3><p>其实这两个没有可比性，但在我们决定是否需要将一个对象通过 <code>mixin</code> 的方式混入到其他对象时就应该考虑这个问题。</p><p>原则上 <strong>复用 &gt; 扩展</strong>。</p><p>如果一个 <code>mixin</code> 只是为了扩展单个对象的功能，而扩展的功能并不能复用到其他的对象时，就不应该使用 <code>mixin</code>，而是直接写在那个对象上更好。</p><p>如果扩展的功能可以被复用的话，那么可以考虑使用 <code>mixin</code>。</p><h2 id="mixin-的缺点"><a href="#mixin-的缺点" class="headerlink" title="mixin 的缺点"></a>mixin 的缺点</h2><blockquote><p><a href="https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html" target="_blank" rel="noopener">mixins-considered-harmful</a> 这篇文章已经列举了一些问题，我简单的列举下</p></blockquote><ol><li><code>mixin</code> 会引入隐性的依赖关系</li><li><code>mixin</code> 会导致命名冲突</li><li><code>mixin</code> 会增加项目的复杂性</li></ol><h2 id="如何正确的使用-Mixin"><a href="#如何正确的使用-Mixin" class="headerlink" title="如何正确的使用 Mixin"></a>如何正确的使用 Mixin</h2><blockquote><p>虽然 <code>mixin</code> 有一些缺点，但正确的使用还是可以方便我们的开发</p><p>没有不合理的设计模式，只有不合理的使用设计模式</p></blockquote><p>首先我们需要解决混入的 <code>mixin</code> 可能会造成隐性的依赖关系，而形成这种依赖关系多半是 <code>mixin</code> 中的扩展功能依赖了被扩展对象想内部数据，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个数据库查看组件</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DatabaseView</span> </span>&#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        database: [&#123;<span class="attr">name</span>: <span class="string">'db1'</span>, <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">tables</span>: [&#123;<span class="attr">name</span>: <span class="string">'table1'</span>, <span class="attr">id</span>: <span class="number">1</span>&#125;]&#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DatabaseView.mixin(viewTabelDetails);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把查看表详情弹窗作为 mixin 混入</span></span><br><span class="line"><span class="keyword">const</span> mixin = &#123;</span><br><span class="line">    viewTabelDetails: <span class="function">(<span class="params">dbId, tableId</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> db = <span class="keyword">this</span>.state.database.filter(<span class="function"><span class="params">db</span> =&gt;</span> db.id === dbId)[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (db) &#123;</span><br><span class="line">            <span class="keyword">const</span> table = db.tables.filter(<span class="function"><span class="params">table</span> =&gt;</span> table.id === tableId)[<span class="number">0</span>];</span><br><span class="line">       </span><br><span class="line">            <span class="keyword">if</span> (table) &#123;</span><br><span class="line">                Model.show(table);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，<code>mixin</code> 依赖的 <code>DarabaseView</code> 中的 <code>database</code> 数据。这就导致了如果页面中其他的组件也需要一个查看表详情弹窗的功能，那么这个组件也必须有类似的 <code>database</code> 数据，形成了一个隐性的依赖关系。</p><p>避免的方式就是 <code>mixin</code> 对象中的功能不要与被扩展对象发生依赖，而在组件开发中这个依赖多半就是使用了被扩展对象的 <code>state</code> 产生的</p><p>至于命名冲突和增加项目的复杂性可以通过其他的方式解决，相比于上面的问题还算简单</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><code>mixin</code> 只是用来扩展对象功能的，而且这个扩展功能是可以被复用的，否则你应该直接写在对象里面</li><li>扩展功能的同时，<code>mixin</code>提供的函数<strong>不应该依赖被扩展对象的内部数据</strong>。因为如果依赖的被扩展对象的内部数据，会使这个 <code>mixin</code> 只能被包含特定数据对象的对象复用，影响 <code>mixin</code> 的复用</li></ol><h2 id="个人主观观点"><a href="#个人主观观点" class="headerlink" title="个人主观观点"></a>个人主观观点</h2><p>其实我觉得在前端的开发中，我们应该避免使用 <code>mixin</code> 去扩展组件的功能</p><p>例如我们完全可以使用函数调用（显性的）去调用 <code>mixin</code> 对象中的方法，而不是一股脑的将 <code>mixin</code> 对象混合到组件中</p><p>每次修改使用了 <code>implement</code> 组件都会特别痛苦（这样导入的方法 WebStorm 根本不识别），极大了增加维护的工作量。同时由于有的 <code>mixin</code> 对象依赖的被扩展对象的内部数据，导致想复用的话还得有相同的数据结构（那还复用个锤子啊）</p><p>所以，不要用 <code>mixin</code> ！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;“类 mixin” 指的是 Vue 中的 mixin，Regular 中的 implement&lt;/p&gt;
&lt;/blockquote&gt;&lt;h2 id=&quot;使用-Mixin-的目的&quot;&gt;&lt;a href=&quot;#使用-Mixin-的目的&quot; class=&quot;headerlink&quot; title=&quot;使用 Mixin 的目的&quot;&gt;&lt;/a&gt;使用 Mixin 的目的&lt;/h2&gt;&lt;h3 id=&quot;首先我们需要知道为什么会有-mixin-的存在？&quot;&gt;&lt;a href=&quot;#首先我们需要知道为什么会有-mixin-的存在？&quot; class=&quot;headerlink&quot; title=&quot;首先我们需要知道为什么会有 mixin 的存在？&quot;&gt;&lt;/a&gt;首先我们需要知道为什么会有 &lt;code&gt;mixin&lt;/code&gt; 的存在？&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;为了扩展对象（组件）的功能&lt;/p&gt;
&lt;p&gt;扩展对象功能的需求是很容易的理解的。比如业务开发时会碰到跨模块传递消息的需求，常用的方法是使用 “发布-订阅模式” 来创建一个全局的&lt;code&gt;EventEmitter&lt;/code&gt;。不使用 &lt;code&gt;mixin&lt;/code&gt; 时的使用方法如下&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// global/eventEmitter&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;EventEmitter&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    on(eventName, handle) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    emit(eventName) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ComponentA&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; EventEmitter &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;global/eventEmitter&#39;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 全局的 EventEmitter 对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ComponentA&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;constructor&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        EventEmitter.on(&lt;span class=&quot;string&quot;&gt;&#39;event&#39;&lt;/span&gt;, () =&amp;gt; &amp;#123;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ComponentB&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; EventEmitter &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;global/eventEmitter&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ComponentB&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;constructor&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        EventEmitter.emit(&lt;span class=&quot;string&quot;&gt;&#39;event&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;我们需要在不同的组件中引入 &lt;code&gt;EventEmitter&lt;/code&gt; 来使用它&lt;/p&gt;
&lt;p&gt;如果使用 &lt;code&gt;mixin&lt;/code&gt; 的话，我们可以这样做&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// eventEmitter mixin&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; EventEmitter &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;global/eventEmitter&#39;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 全局的 EventEmitter 对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; eventEmitterMixin = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    on: &lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;eventName, handle&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &amp;#123;EventEmitter.on(eventName, handle)&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fire: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;EventEmitter.emit(eventName)&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Root Component&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Component.mixin(eventEmitterMixin);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ComponentA&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ComponentA&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;constructor&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.on(&lt;span class=&quot;string&quot;&gt;&#39;event&#39;&lt;/span&gt;, () =&amp;gt; &amp;#123;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ComponentB&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ComponentB&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;constructor&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.emit(&lt;span class=&quot;string&quot;&gt;&#39;event&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这样通过&lt;code&gt;mixin&lt;/code&gt;来扩展了组件的功能，是每个组件都可以方便的使用 &lt;code&gt;EventEmitter&lt;/code&gt; 的功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为了复用代码&lt;/p&gt;
&lt;p&gt;软件开发中的 &lt;code&gt;DRY&lt;/code&gt; 原则还是有必要遵守的。过多的重复代码会导致维护上的麻烦，通过 &lt;code&gt;mixin&lt;/code&gt; ，我们可以在不同的对象上使用同一份代码来完成相同的功能，减轻我们维护的压力。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="前端" scheme="https://lleohao.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="设计模式" scheme="https://lleohao.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>使用 HTTP2 做开发服务器 (上)</title>
    <link href="https://lleohao.github.io/2018/03/27/%E4%BD%BF%E7%94%A8-HTTP2-%E5%81%9A%E5%BC%80%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%20(%E4%B8%8A)/"/>
    <id>https://lleohao.github.io/2018/03/27/使用-HTTP2-做开发服务器 (上)/</id>
    <published>2018-03-27T01:50:00.000Z</published>
    <updated>2020-11-24T06:07:16.912Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写作背景"><a href="#写作背景" class="headerlink" title="写作背景"></a>写作背景</h2><p>笔者所在项目使用的前端技术比较老旧，在开发的过程中需要先启动一个后端项目 (tomcat + mysql + redis) 来做为静态服务器</p><p>然后使用的是一个公司内部的类AMD模块加载工具，每次刷新页面都要加载1000+ 的文件，页面的响应时间接近20s， 导致开发的过程非常痛苦</p><p>所以决定使用 HTTP/2 来开发一个开发服务器来加快页面的加载速度. 目前来说效果不错，相对于 HTTP1.1 来说加载<strong>速度提升了 50%</strong>。</p><p>对于开发环境与我们类似的项目，可以尝试一下。</p><h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><h3 id="1-HTTP-2-的TCP连接复用"><a href="#1-HTTP-2-的TCP连接复用" class="headerlink" title="1. HTTP/2 的TCP连接复用"></a>1. HTTP/2 的TCP连接复用</h3><p>虽然我们开发的时候使用的是本地服务器，建立连接的速度和下载速度都很快，但是浏览器针对同一域名的并发请求是有上限的。</p><a id="more"></a><p>当所需要的文件数量很多时，我们每次只能请求一定数量的文件，当前面的文件的请求完成后才能去请求下一个文件，这就造成了堵塞。</p><p><img src="./http2-1.png" alt></p><p><em>从图中我们可以看到明显的链接限制和堵塞</em></p><p>而 HTTP/2 可以在同一连接上进行多个并发交换，可以避免出现因为浏览器的并发限制而造成的堵塞</p><blockquote><p>HTTP/2 通过支持标头字段压缩和在同一连接上进行多个并发交换，让应用更有效地利用网络资源，减少感知的延迟时间。具体来说，它可以对同一连接上的请求和响应消息进行交错发送并为 HTTP 标头字段使用有效编码。 HTTP/2 还允许为请求设置优先级，让更重要的请求更快速地完成，从而进一步提升性能。出台的协议对网络更加友好，因为与 HTTP/1.x 相比，可以使用更少的 TCP 连接。 这意味着与其他流的竞争减小，并且连接的持续时间变长，这些特性反过来提高了可用网络容量的利用率。 最后，HTTP/2 还可以通过使用二进制消息分帧对消息进行更高效的处理。（超文本传输协议版本 2，草案 17） - <a href="https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn</a></p></blockquote><h3 id="2-Server-Push-服务器推送"><a href="#2-Server-Push-服务器推送" class="headerlink" title="2. Server Push 服务器推送"></a>2. Server Push 服务器推送</h3><p>HTTP/2 中最令人期待的特性就是 Sever Push (服务器推送)。</p><p>通过 Server Push，服务器可以对浏览器的<strong>单个请求返回多个响应</strong>，而不需要等待浏览器发出请求再给去响应。</p><p>简单举个🌰</p><ol><li>浏览器向服务器发送 a.com 请求</li><li>服务器确定这个请求返回一个 index.html 文件，同时发现这个文件需要 style.css 和 script.js 文件</li><li>服务器向浏览器放回  index.html 的响应，同时告诉浏览器我这里有 style.css 和 script.js 文件你可能需要</li><li>浏览器收到 index.html 后，解析后发现需要 style.css 和 script.js，正好服务器端说可以推送这两个资源，浏览器就不需要再次发送请求去获取，而是直接就收服务器的推送</li></ol><p>结合上面的连接复用，HTTP/2 可以极大的加快资源文件的加载速度</p><p><img src="./http2-2.png" alt></p><p><em>可以看到浏览器使用一个链接加载完了所有的资源文件</em></p><h2 id="Nodejs-HTTP-2-模块简单使用"><a href="#Nodejs-HTTP-2-模块简单使用" class="headerlink" title="Nodejs HTTP/2 模块简单使用"></a>Nodejs HTTP/2 模块简单使用</h2><blockquote><p>这里先简单介绍下 Node 中 HTTP/2 的使用，下篇文章将详细阐述如何编写一个可以应用的 HTTP/2 开发服务器</p></blockquote><h3 id="1-创建-HTTPS-证书"><a href="#1-创建-HTTPS-证书" class="headerlink" title="1. 创建 HTTPS 证书"></a>1. 创建 HTTPS 证书</h3><p>由于 HTTP/2 需要使用 HTTPS，这里我们需要先生成一个证书。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl req -x509 -newkey rsa:2048 -nodes -sha256 -subj '/CN=localhost' \</span><br><span class="line">  -keyout localhost-privkey.pem -out localhost-cert.pem</span><br></pre></td></tr></table></figure><h3 id="2-项目结构"><a href="#2-项目结构" class="headerlink" title="2. 项目结构"></a>2. 项目结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── certificate</span><br><span class="line">│   ├── localhost-cert.pem</span><br><span class="line">│   └── localhost-privkey.pem</span><br><span class="line">├── node_modules</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">├── src</span><br><span class="line">│   └── app.js</span><br><span class="line">└── www</span><br><span class="line">    ├── index.html</span><br><span class="line">    ├── script.js</span><br><span class="line">    └── styles.css</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- www/index.html --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>HTTP2 demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"styles.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"script.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// www/script.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> content = <span class="built_in">document</span>.querySelector(<span class="string">"#content"</span>);</span><br><span class="line"></span><br><span class="line">content.innerHTML = <span class="string">`&lt;h1&gt;Hello HTTP/2&lt;/h1&gt;`</span>;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* www/styles.css */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: cornflowerblue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建如上的项目结构</p><h2 id="3-创建服务器"><a href="#3-创建服务器" class="headerlink" title="3. 创建服务器"></a>3. 创建服务器</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http2 = <span class="built_in">require</span>(<span class="string">"http2"</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http2.createSecureServer(&#123;</span><br><span class="line">  key: fs.readFileSync(</span><br><span class="line">    path.resolve(__dirname, <span class="string">"../certificate/localhost-privkey.pem"</span>)</span><br><span class="line">  ),</span><br><span class="line">  cert: fs.readFileSync(</span><br><span class="line">    path.resolve(__dirname, <span class="string">"../certificate/localhost-cert.pem"</span>)</span><br><span class="line">  )</span><br><span class="line">&#125;);</span><br><span class="line">server.on(<span class="string">"error"</span>, err =&gt; <span class="built_in">console</span>.error(err));</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">"stream"</span>, (stream, headers) =&gt; &#123;</span><br><span class="line">  <span class="comment">// stream is a Duplex</span></span><br><span class="line">  stream.respond(&#123;</span><br><span class="line">    <span class="string">"content-type"</span>: <span class="string">"text/html"</span>,</span><br><span class="line">    <span class="string">":status"</span>: <span class="number">200</span></span><br><span class="line">  &#125;);</span><br><span class="line">  stream.end(<span class="string">"&lt;h1&gt;Hello World&lt;/h1&gt;"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8443</span>);</span><br></pre></td></tr></table></figure><p>打开控制台，进入 Network ，开启 Protocol 显示</p><p><img src="./http-3.png" alt></p><p>访问 <a href="https://localhost:8443/" target="_blank" rel="noopener">https://localhost:8443/</a> ，即可看到协议变为 <code>h2</code></p><p><img src="./http2-4.png" alt></p><h3 id="4-启用服务器端推送"><a href="#4-启用服务器端推送" class="headerlink" title="4. 启用服务器端推送"></a>4. 启用服务器端推送</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http2 = <span class="built_in">require</span>(<span class="string">"http2"</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pemPath = path.resolve(__dirname, <span class="string">"../certificate/localhost-privkey.pem"</span>);</span><br><span class="line"><span class="keyword">const</span> certPaht = path.resolve(__dirname, <span class="string">"../certificate/localhost-cert.pem"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 HTTP2 header 常量</span></span><br><span class="line"><span class="keyword">const</span> &#123; HTTP2_HEADER_PATH, HTTP2_HEADER_STATUS &#125; = http2.constants;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取静态目录下的所有文件信息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFileInfoMap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> fileInfoMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">const</span> fileList = fs.readdirSync(staticPath);</span><br><span class="line">  <span class="keyword">const</span> contentTypeMap = &#123;</span><br><span class="line">    js: <span class="string">"application/javascript"</span>,</span><br><span class="line">    css: <span class="string">"text/css"</span>,</span><br><span class="line">    html: <span class="string">"text/html"</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  fileList.forEach(<span class="function"><span class="params">file</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fd = fs.openSync(path.resolve(staticPath, file), <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">const</span> contentType = contentTypeMap[file.split(<span class="string">"."</span>)[<span class="number">1</span>]];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> stat = fs.fstatSync(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> headers = &#123;</span><br><span class="line">      <span class="string">"content-length"</span>: stat.size,</span><br><span class="line">      <span class="string">"last-modified"</span>: stat.mtime.toUTCString(),</span><br><span class="line">      <span class="string">"content-type"</span>: contentType</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fileInfoMap.set(<span class="string">`/<span class="subst">$&#123;file&#125;</span>`</span>, &#123;</span><br><span class="line">      fd,</span><br><span class="line">      headers</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fileInfoMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义静态目录</span></span><br><span class="line"><span class="keyword">const</span> staticPath = path.resolve(__dirname, <span class="string">"../www"</span>);</span><br><span class="line"><span class="keyword">const</span> fileInfoMap = createFileInfoMap();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将传入的文件推送到浏览器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">stream, path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> file = fileInfoMap.get(path);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!file) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stream.pushStream(&#123; [HTTP2_HEADER_PATH]: path &#125;, (err, pushStream) =&gt; &#123;</span><br><span class="line">    pushStream.respondWithFD(file.fd, file.headers);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http2.createSecureServer(&#123;</span><br><span class="line">  key: fs.readFileSync(pemPath),</span><br><span class="line">  cert: fs.readFileSync(certPaht)</span><br><span class="line">&#125;);</span><br><span class="line">server.on(<span class="string">"error"</span>, err =&gt; <span class="built_in">console</span>.error(err));</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">"stream"</span>, (stream, headers) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 获取请求路径</span></span><br><span class="line">  <span class="keyword">let</span> requestPath = headers[HTTP2_HEADER_PATH];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请求到 '/' 的请求返回 index.html</span></span><br><span class="line">  <span class="keyword">if</span> (requestPath === <span class="string">"/"</span>) &#123;</span><br><span class="line">    requestPath = <span class="string">"/index.html"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据请求路径获取对应的文件信息</span></span><br><span class="line">  <span class="keyword">const</span> fileInfo = fileInfoMap.get(requestPath);</span><br><span class="line">  <span class="keyword">if</span> (!fileInfo) &#123;</span><br><span class="line">    stream.respond(&#123;</span><br><span class="line">      [HTTP2_HEADER_STATUS]: <span class="number">404</span></span><br><span class="line">    &#125;);</span><br><span class="line">    stream.end(<span class="string">"Not found"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 访问首页时同时推送其他文件资源</span></span><br><span class="line">  <span class="keyword">if</span> (requestPath === <span class="string">"/index.html"</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> fileInfoMap.keys()) &#123;</span><br><span class="line">      push(stream, key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 推送首页数据</span></span><br><span class="line">  stream.respondWithFD(fileInfo.fd, &#123;</span><br><span class="line">    ...fileInfo.headers</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8443</span>);</span><br></pre></td></tr></table></figure><p>访问 <a href="https://localhost:8443" target="_blank" rel="noopener">https://localhost:8443</a> 就可以看到 styles.css 和 script.js 是通过 HTTP/2 推送过来的</p><p><img src="./http2-6.png" alt></p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ol><li><a href="https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn#_4" target="_blank" rel="noopener">HTTP/2 简介  |  Web  |  Google Developers</a></li><li><a href="http://www.alloyteam.com/2017/04/guide-http2-server-push-part1/" target="_blank" rel="noopener">HTTP/2 Server Push 详解（上） | AlloyTeam</a></li><li><a href="http://www.alloyteam.com/2017/04/guide-http2-server-push-part2/" target="_blank" rel="noopener">HTTP/2 Server Push 详解（下） | AlloyTeam</a></li><li><a href="./node-http2-demo.zip">demo 下载地址</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写作背景&quot;&gt;&lt;a href=&quot;#写作背景&quot; class=&quot;headerlink&quot; title=&quot;写作背景&quot;&gt;&lt;/a&gt;写作背景&lt;/h2&gt;&lt;p&gt;笔者所在项目使用的前端技术比较老旧，在开发的过程中需要先启动一个后端项目 (tomcat + mysql + redis) 来做为静态服务器&lt;/p&gt;&lt;p&gt;然后使用的是一个公司内部的类AMD模块加载工具，每次刷新页面都要加载1000+ 的文件，页面的响应时间接近20s， 导致开发的过程非常痛苦&lt;/p&gt;&lt;p&gt;所以决定使用 HTTP/2 来开发一个开发服务器来加快页面的加载速度. 目前来说效果不错，相对于 HTTP1.1 来说加载&lt;strong&gt;速度提升了 50%&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;对于开发环境与我们类似的项目，可以尝试一下。&lt;/p&gt;&lt;h2 id=&quot;理论基础&quot;&gt;&lt;a href=&quot;#理论基础&quot; class=&quot;headerlink&quot; title=&quot;理论基础&quot;&gt;&lt;/a&gt;理论基础&lt;/h2&gt;&lt;h3 id=&quot;1-HTTP-2-的TCP连接复用&quot;&gt;&lt;a href=&quot;#1-HTTP-2-的TCP连接复用&quot; class=&quot;headerlink&quot; title=&quot;1. HTTP/2 的TCP连接复用&quot;&gt;&lt;/a&gt;1. HTTP/2 的TCP连接复用&lt;/h3&gt;&lt;p&gt;虽然我们开发的时候使用的是本地服务器，建立连接的速度和下载速度都很快，但是浏览器针对同一域名的并发请求是有上限的。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>在 Heroku 上开发、部署Node程序的快速指南</title>
    <link href="https://lleohao.github.io/2018/03/25/%E5%9C%A8-Heroku-%E4%B8%8A%E5%BC%80%E5%8F%91%E3%80%81%E9%83%A8%E7%BD%B2Node%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97/"/>
    <id>https://lleohao.github.io/2018/03/25/在-Heroku-上开发、部署Node程序的快速指南/</id>
    <published>2018-03-25T04:14:41.000Z</published>
    <updated>2020-11-24T06:07:16.916Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>尝试使用了下Heroku, 在上面部署 Node 程序还是很方便的, 主要优势在于它的网络可以访问到外网, 具体应用都懂得</p><p>这里记录下如何在 Heroku 上创建、开发、部署 Node </p><p><a href="https://devcenter.heroku.com/articles/getting-started-with-nodejs#introduction" target="_blank" rel="noopener">官方的文档在这里</a></p></blockquote><h2 id="安装-Heroku-cli"><a href="#安装-Heroku-cli" class="headerlink" title="安装 Heroku cli"></a>安装 Heroku cli</h2><ul><li><a href="https://cli-assets.heroku.com/branches/stable/heroku-osx.pkg" target="_blank" rel="noopener">Mac os</a></li><li><a href="https://cli-assets.heroku.com/branches/stable/heroku-windows-amd64.exe" target="_blank" rel="noopener">Windows 64</a></li></ul><p>其余的访问 <a href="https://devcenter.heroku.com/articles/getting-started-with-nodejs#set-up" target="_blank" rel="noopener">下载地址</a></p><h2 id="创建一个-Express-应用"><a href="#创建一个-Express-应用" class="headerlink" title="创建一个 Express 应用"></a>创建一个 Express 应用</h2><p>使用<code>Yeoman</code>和<code>generator-express</code>来快速创建一个 Express 应用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 安装 yeoman</span><br><span class="line">npm install -g yo</span><br><span class="line"></span><br><span class="line">// 安装 generator-express</span><br><span class="line">npm install -g generator-express </span><br><span class="line"></span><br><span class="line">// 新建项目文件夹</span><br><span class="line">mkdir heroku-express</span><br><span class="line">cd heroku-express</span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line">// 创建项目</span><br><span class="line">yo express </span><br><span class="line"></span><br><span class="line">// 提交代码</span><br><span class="line">git add .</span><br><span class="line">git commit -m "Init project"</span><br></pre></td></tr></table></figure><a id="more"></a><p>测试一下刚刚创建的项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 启动 Express</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><p>访问 <a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000/</a> 查看 Express 是否成功启动</p><h2 id="在-Heroku-上创建项目"><a href="#在-Heroku-上创建项目" class="headerlink" title="在 Heroku 上创建项目"></a>在 Heroku 上创建项目</h2><p>进入我们刚刚新建的项目, 运行 <code>create</code> 指令创建项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heroku create [your_app_name]</span><br></pre></td></tr></table></figure><p>运行完成后, Heroku 会在我们的项目上新建一个<code>git</code> 的远程分支, 同时会为项目创建一个域名供我们访问</p><p>这里是我的运行结果<img src="./heroku-1.png" alt="运行结果"></p><h2 id="在-Heroku-上部署应用"><a href="#在-Heroku-上部署应用" class="headerlink" title="在 Heroku 上部署应用"></a>在 Heroku 上部署应用</h2><p>部署之前我们需要创建一个类似启动脚本的文件 <code>Procfile</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Profile </span><br><span class="line"></span><br><span class="line">web: node ./bin/www</span><br></pre></td></tr></table></figure><p>这个文件告诉 <code>Heroku</code>需要创建一个web 容器, 同时执行 <code>node ./bin/www</code> 来启动程序</p><blockquote><p>我们的项目只需要这样就可以了, 更多的详细信息在这里 <a href="https://devcenter.heroku.com/articles/procfile" target="_blank" rel="noopener">Process Types and the Procfile</a></p></blockquote><p>然后将刚刚的改动提交, 同时推送的 Heroku</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git ci -m &quot;Add procfile&quot;</span><br><span class="line"></span><br><span class="line">git push heroku master</span><br></pre></td></tr></table></figure><p><strong>当你将代码推送到 Heroku 的 master 分支上时, 它就会根据<code>package.json</code>中的内容安装所需要的依赖, 然后执行 <code>Procfile</code> 中的内容, 这就完成的程序的部署</strong></p><p>这里是我的部署结果</p><p><img src="./heroku-2.png" alt></p><p>然后你在访问刚刚 Heroku 给的网址, 就可以看到程序已经运行</p><h2 id="定义程序依赖和运行变量"><a href="#定义程序依赖和运行变量" class="headerlink" title="定义程序依赖和运行变量"></a>定义程序依赖和运行变量</h2><ol><li><p>通过<code>package.json</code>定义程序依赖</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"heroku-express"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.1"</span>,</span><br><span class="line">  ...</span><br><span class="line">  "dependencies": &#123;</span><br><span class="line">    "express": "^4.13.3",</span><br><span class="line">    "serve-favicon": "^2.3.0",</span><br><span class="line">    "morgan": "^1.6.1",</span><br><span class="line">    "cookie-parser": "^1.3.3",</span><br><span class="line">    "body-parser": "^1.13.3",</span><br><span class="line">    "swig": "^1.4.2"</span><br><span class="line">  &#125;,</span><br><span class="line">  ... </span><br><span class="line">  "engines": &#123;</span><br><span class="line">    "node": "^8.3.0"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dependencies 字段定义程序依赖</p><p>engines 字段定义需要的 Node 版本</p><p>​</p></li><li><p>定义运行变量</p><ol><li><p>本地运行变量</p><p>本地使用 <code>.env</code> 文件来定义变量, 格式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NAME=VALUE</span><br></pre></td></tr></table></figure><p>使用 <code>heroku local web</code> 来启动本地开发服务器, 同时会将变量信息注入到<code>process.env</code>中</p></li><li><p>容器运行变量</p><p>容器的运行变量需要通过 <code>heroku config:set NAME=VALUE</code>来设置</p><p>使用 <code>heroku config</code>来查看变量</p></li></ol><blockquote><p>详细信息 <a href="https://devcenter.heroku.com/articles/config-vars" target="_blank" rel="noopener">Configuration and Config Vars</a></p></blockquote><p>​</p></li></ol><h2 id="与容器进行远程交互"><a href="#与容器进行远程交互" class="headerlink" title="与容器进行远程交互"></a>与容器进行远程交互</h2><ol><li><p>查看运行日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heroku logs --tail</span><br></pre></td></tr></table></figure></li><li><p>在容器中运行命令 <code>heroku run command</code></p><ol><li><code>heroku run node</code> 进入Node 的 REPL</li><li><code>heroku run bash</code> 进去容器运行bash</li></ol></li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>Heroku 的免费版本每个月提供了 550 小时的使用时间, 当我们的程序半个小时内没有访问流量时就会被休眠掉, 在下次被访问的时候激活</p><p>所以长时间没有访问的应用, 在第一次访问会很慢, 不过也就够用了</p><p>我也将这篇文章部署在这个应用上, <a href="https://lleohao-heroku-express.herokuapp.com/article" target="_blank" rel="noopener">https://lleohao-heroku-express.herokuapp.com/article</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;尝试使用了下Heroku, 在上面部署 Node 程序还是很方便的, 主要优势在于它的网络可以访问到外网, 具体应用都懂得&lt;/p&gt;
&lt;p&gt;这里记录下如何在 Heroku 上创建、开发、部署 Node &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://devcenter.heroku.com/articles/getting-started-with-nodejs#introduction&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方的文档在这里&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;h2 id=&quot;安装-Heroku-cli&quot;&gt;&lt;a href=&quot;#安装-Heroku-cli&quot; class=&quot;headerlink&quot; title=&quot;安装 Heroku cli&quot;&gt;&lt;/a&gt;安装 Heroku cli&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://cli-assets.heroku.com/branches/stable/heroku-osx.pkg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Mac os&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cli-assets.heroku.com/branches/stable/heroku-windows-amd64.exe&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Windows 64&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其余的访问 &lt;a href=&quot;https://devcenter.heroku.com/articles/getting-started-with-nodejs#set-up&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;下载地址&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;创建一个-Express-应用&quot;&gt;&lt;a href=&quot;#创建一个-Express-应用&quot; class=&quot;headerlink&quot; title=&quot;创建一个 Express 应用&quot;&gt;&lt;/a&gt;创建一个 Express 应用&lt;/h2&gt;&lt;p&gt;使用&lt;code&gt;Yeoman&lt;/code&gt;和&lt;code&gt;generator-express&lt;/code&gt;来快速创建一个 Express 应用&lt;/p&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 安装 yeoman&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install -g yo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 安装 generator-express&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install -g generator-express &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 新建项目文件夹&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mkdir heroku-express&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd heroku-express&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git init&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 创建项目&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yo express &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 提交代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git add .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git commit -m &quot;Init project&quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>对复杂业务组件在实际开发过程中被调用的反思</title>
    <link href="https://lleohao.github.io/2017/10/12/%E5%AF%B9%E5%A4%8D%E6%9D%82%E4%B8%9A%E5%8A%A1%E7%BB%84%E4%BB%B6%E5%9C%A8%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%A2%AB%E8%B0%83%E7%94%A8%E7%9A%84%E5%8F%8D%E6%80%9D/"/>
    <id>https://lleohao.github.io/2017/10/12/对复杂业务组件在实际开发过程中被调用的反思/</id>
    <published>2017-10-12T12:32:22.000Z</published>
    <updated>2020-11-24T06:07:16.916Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写这篇文章的初衷是为了记录我在修复项目中一个复杂业务组件中的bug而引起其他依赖这个组件的功能无法使用的过程中，对使用、维护复杂业务组件的一些思考</p></blockquote><h2 id="Bug发生原因"><a href="#Bug发生原因" class="headerlink" title="Bug发生原因"></a>Bug发生原因</h2><p>我所在的项目组中, 有一个类似树状文件管理的需求</p><p>对于这样的需求，当时我设计一个基础的UI组件<code>treeListView</code>用来实现基础的树状UI， 同时在其基础上实现了<code>explorer</code>业务组件来实现具体的业务逻辑。</p><p>由于是树状的视图，所以在当时设计数据结构时也采用树作为数据结构。为了能够方便的查找树中的数据，我按照系统的文件管理给所有的数据添加了一个<code>path</code>属性。</p><p>但是在实现的时候没有考虑到同级目录下面可能同时存在同名的文件夹和文件这种情况，假设文件夹<code>folder</code>下面同时存在名为<code>file</code>的文件和文件夹，这个时候会造成它们的路径相同，在查找的时候无法区分这两个数据。修复的方法是在文件夹的路径后面增加<code>/</code>。</p><a id="more"></a><p>这样修复后，由于在我们的项目中有许多的地方直接使用<code>path</code>来来做判读，例如有的地方直接分割<code>path</code>来获取当前数据的名称或者其父元素的名称（虽然有更好的方式获取这些数据，但是开发过程中可能为了省事直接这样获取），或者在新建文件、文件夹时自己手动的拼写<code>path</code>。</p><p>当我按照上面的方式修复bug时，就必须同时修改这个依赖<code>path</code>的函数操作，当项目中的代码太多时就可能出现遗漏的情况，给代码的维护带来很大的困扰。</p><h2 id="为什么会出现这么多的问题"><a href="#为什么会出现这么多的问题" class="headerlink" title="为什么会出现这么多的问题?"></a>为什么会出现这么多的问题?</h2><p>问题出现了之后就应该去反思为什么造成现在这样的局面。诚然有一部分的原因是我们在开发过程中经常会图方便而随意的使用数据，但是根本的原因是在对一个复杂的业务组件调用过程中，没有一个方便、有效的操作造成的。换句话说就是对于<strong>组件依赖的数据没有一个有效的操作</strong>造成的。</p><p>组件的正确依赖于数据的正确，而在开发的过程中不同的开发人员有着不同的风格的数据处理方式。 一旦数据结构出现了错误或者发生了修改，就会导致组件出现意想不到问题。</p><h2 id="如何解决这样的问题"><a href="#如何解决这样的问题" class="headerlink" title="如何解决这样的问题?"></a>如何解决这样的问题?</h2><p>对于业务组件, 我们是可以总结出对这个业务组件的调用的使用情况，例如本文中的<code>explorer</code>组件主要有以下几种情况:</p><ol><li>新建文件夹、文件</li><li>删除文件夹、文件</li><li>修改文件夹、文件</li><li>根据路径查找文件夹、文件</li><li>根据路径查找父文件夹</li></ol><p>对于这些操作，在组件的编写过程中我们可以同时编写对应的辅助函数，</p><p>如<code>explorer</code>组件我就编写下面的辅助函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  <span class="comment">// 修改属性操作</span></span><br><span class="line">  modify: modify,</span><br><span class="line">  <span class="comment">// 重命名操作</span></span><br><span class="line">  rename: rename,</span><br><span class="line">  <span class="comment">// 新建操作</span></span><br><span class="line">  create: create,</span><br><span class="line">  <span class="comment">// 复制操作</span></span><br><span class="line">  copy: copy,</span><br><span class="line">  <span class="comment">// 移动操作</span></span><br><span class="line">  move: move,</span><br><span class="line">  <span class="comment">// 删除操作</span></span><br><span class="line">  remove: remove,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 搜索树中符合要求的数据</span></span><br><span class="line">  searchTree: searchTree,</span><br><span class="line">  <span class="comment">// 根据路径返回在树种的索引</span></span><br><span class="line">  searchByPath: searchByPath,</span><br><span class="line">  <span class="comment">// 根据路径获取数据</span></span><br><span class="line">  getDataByPath: getDataByPath,</span><br><span class="line">  <span class="comment">// 根据路径获取父目录的数据</span></span><br><span class="line">  getParentDataByPath: getParentDataByPath,</span><br><span class="line">  <span class="comment">// 根据路径获取父目录路径</span></span><br><span class="line">  getParentPath: getParentPath</span><br><span class="line">  <span class="comment">// 初始化数据中的path</span></span><br><span class="line">  addSourcePath: addSourcePath,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 判断是否存在同名数据(用于新建时同名判断)</span></span><br><span class="line">  hasSameName: hasSameName</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样对于调用者来说，只要使用组件提供的辅助函数就可以方便的使用组件；对于组件的维护者来说，只要保证辅助函数的正确性，就可以保证组件在被调用的过程的正确，方便组件的维护。</p><p>总的来说，就是在编写这样复杂的业务组件，我们应该同时编写相关的辅助函数来方便组件的调用者来使用。而我们在开发中也应当避免写出上文中那样对数据直接进行操作的代码，这会导致业务的正确依赖于组件的内部数据相耦合，使组件难以维护。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;写这篇文章的初衷是为了记录我在修复项目中一个复杂业务组件中的bug而引起其他依赖这个组件的功能无法使用的过程中，对使用、维护复杂业务组件的一些思考&lt;/p&gt;
&lt;/blockquote&gt;&lt;h2 id=&quot;Bug发生原因&quot;&gt;&lt;a href=&quot;#Bug发生原因&quot; class=&quot;headerlink&quot; title=&quot;Bug发生原因&quot;&gt;&lt;/a&gt;Bug发生原因&lt;/h2&gt;&lt;p&gt;我所在的项目组中, 有一个类似树状文件管理的需求&lt;/p&gt;&lt;p&gt;对于这样的需求，当时我设计一个基础的UI组件&lt;code&gt;treeListView&lt;/code&gt;用来实现基础的树状UI， 同时在其基础上实现了&lt;code&gt;explorer&lt;/code&gt;业务组件来实现具体的业务逻辑。&lt;/p&gt;&lt;p&gt;由于是树状的视图，所以在当时设计数据结构时也采用树作为数据结构。为了能够方便的查找树中的数据，我按照系统的文件管理给所有的数据添加了一个&lt;code&gt;path&lt;/code&gt;属性。&lt;/p&gt;&lt;p&gt;但是在实现的时候没有考虑到同级目录下面可能同时存在同名的文件夹和文件这种情况，假设文件夹&lt;code&gt;folder&lt;/code&gt;下面同时存在名为&lt;code&gt;file&lt;/code&gt;的文件和文件夹，这个时候会造成它们的路径相同，在查找的时候无法区分这两个数据。修复的方法是在文件夹的路径后面增加&lt;code&gt;/&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="前端" scheme="https://lleohao.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="https://lleohao.github.io/tags/JavaScript/"/>
    
      <category term="组件化开发" scheme="https://lleohao.github.io/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>如何搭建Electron开发环境</title>
    <link href="https://lleohao.github.io/2017/09/02/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAElectron%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>https://lleohao.github.io/2017/09/02/如何搭建Electron开发环境/</id>
    <published>2017-09-02T02:29:50.000Z</published>
    <updated>2020-11-24T06:07:16.916Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这个项目结构是我在编写  <a href="https://github.com/lleohao/qiniu-upload" target="_blank" rel="noopener">基于Electron 和 Angular 的七牛文件上传App</a>  总结出来的</p><p>本文主要介绍如何从零开始搭建高效的Electron开发环境, 主要内容如下：</p><ol><li>通过合理的目录划分来组织代码</li><li>使用<code>npm script</code>简化开发</li><li>如何在渲染进程开发时使用热更新</li><li>如何在主进程开发时使用自动重启</li><li>如何在主进程开发时使用<code>Typescript</code></li><li>如何打包和发布软件</li></ol><p>示例项目地址 <a href="https://github.com/lleohao/electron-base" target="_blank" rel="noopener">https://github.com/lleohao/electron-base</a></p></blockquote><h2 id="目录结构划分"><a href="#目录结构划分" class="headerlink" title="目录结构划分"></a>目录结构划分</h2><h3 id="初始化目录"><a href="#初始化目录" class="headerlink" title="初始化目录"></a>初始化目录</h3><p>首先按照常规的方法新建一个项目文件夹(这里我的示例文件夹叫做<code>electron-base</code>， 然后使用<code>npm init</code>初始化目录。</p><a id="more"></a><p>目前我们的开发目录如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">electorn-base</span><br><span class="line">├── .gitignore - git忽略文件</span><br><span class="line">├── LICENSE - 开源协议</span><br><span class="line">├── README.md - 文档</span><br><span class="line">└── package.json - npm package</span><br></pre></td></tr></table></figure><h3 id="目录划分"><a href="#目录划分" class="headerlink" title="目录划分"></a>目录划分</h3><p>Electron 的开发主要分为两个部分,  其中主进程(Main Process)主要负责打开页面和调用系统底层的资源等, 渲染进程(Renderer Process)则是一个普通的网页窗口.</p><p>两个进程的开发有着不同的开发方式, 主进程更像是传统<code>Node</code>的开发, 而渲染进程则是普通的前端开发. 同时它们之间又有着可以共用的部分(如辅助函数、数据模型等), 因此可以按照下面的方式划分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">electorn-base</span><br><span class="line">├── ... - 省略</span><br><span class="line">└── src - 代码源文件</span><br><span class="line">    ├── main - 主线程代码</span><br><span class="line">    ├── renderer - 渲染线程</span><br><span class="line">    └── shared - 公用代码</span><br></pre></td></tr></table></figure><h3 id="Electron-quick-start"><a href="#Electron-quick-start" class="headerlink" title="Electron quick start"></a>Electron quick start</h3><p>接下来运行<code>npm install electron -D</code>安装Electron，同时在<code>package.json</code>添加<code>main</code>字段， 这代表整个项目的入口文件，这里我们先设置为<code>src/main/main.js</code>.</p><p>顺便添加上两个文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"># src/main.js</span><br><span class="line"><span class="keyword">const</span> &#123; app, BrowserWindow &#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> win</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWindow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    win = <span class="keyword">new</span> BrowserWindow(&#123; <span class="attr">width</span>: <span class="number">800</span>, <span class="attr">height</span>: <span class="number">600</span> &#125;)</span><br><span class="line"></span><br><span class="line">    win.loadURL(url.format(&#123;</span><br><span class="line">        pathname: path.join(__dirname, <span class="string">'../renderer/index.html'</span>),</span><br><span class="line">        protocol: <span class="string">'file:'</span>,</span><br><span class="line">        slashes: <span class="literal">true</span></span><br><span class="line">    &#125;))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open the DevTools.</span></span><br><span class="line">    win.webContents.openDevTools()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Emitted when the window is closed.</span></span><br><span class="line">    win.on(<span class="string">'closed'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// Dereference the window object, usually you would store windows</span></span><br><span class="line">        <span class="comment">// in an array if your app supports multi windows, this is the time</span></span><br><span class="line">        <span class="comment">// when you should delete the corresponding element.</span></span><br><span class="line">        win = <span class="literal">null</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This method will be called when Electron has finished</span></span><br><span class="line"><span class="comment">// initialization and is ready to create browser windows.</span></span><br><span class="line"><span class="comment">// Some APIs can only be used after this event occurs.</span></span><br><span class="line">app.on(<span class="string">'ready'</span>, createWindow)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Quit when all windows are closed.</span></span><br><span class="line">app.on(<span class="string">'window-all-closed'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// On macOS it is common for applications and their menu bar</span></span><br><span class="line">    <span class="comment">// to stay active until the user quits explicitly with Cmd + Q</span></span><br><span class="line">    <span class="keyword">if</span> (process.platform !== <span class="string">'darwin'</span>) &#123;</span><br><span class="line">        app.quit()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.on(<span class="string">'activate'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// On macOS it's common to re-create a window in the app when the</span></span><br><span class="line">    <span class="comment">// dock icon is clicked and there are no other windows open.</span></span><br><span class="line">    <span class="keyword">if</span> (win === <span class="literal">null</span>) &#123;</span><br><span class="line">        createWindow()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- src/renderer/index.html --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    We are using node <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">document</span>.write(process.versions.node)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>,</span><br><span class="line">    Chrome <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">document</span>.write(process.versions.chrome)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>,</span><br><span class="line">    and Electron <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">document</span>.write(process.versions.electron)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>.</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在根目录运行<code>electron .</code>(或者是<code>./node_modules/.bin/electron .</code>)启动程序</p><p>为了以后方便启动程序, 将这段命令添加到<code>package.json</code>中</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// package.json 部分内容</span><br><span class="line">"main": "src/main/main.js",</span><br><span class="line">"scripts": &#123;</span><br><span class="line">"start": "./node_modules/.bin/electron ."</span><br><span class="line">&#125;,</span><br><span class="line">"devDependencies": &#123;</span><br><span class="line">"electron": "^1.7.5"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="开发渲染线程"><a href="#开发渲染线程" class="headerlink" title="开发渲染线程"></a>开发渲染线程</h2><p>渲染线程的开发跟普通的前端开发没有多大的区别, 为了开发的效率, 我们通常会选择一款前端开发框架, 这里我选择的是<code>Angular</code>, 当然也可以选择其他的框架, 只需要按照下文中的要求修改打包路径.</p><h3 id="导入Angular-可选-使用其他框架可以跳过"><a href="#导入Angular-可选-使用其他框架可以跳过" class="headerlink" title="导入Angular(可选, 使用其他框架可以跳过)"></a>导入Angular(可选, 使用其他框架可以跳过)</h3><p>这里我使用<code>Angular-cli</code>工具来初始化项目</p><ol><li><p>安装cli工具</p><p> <code>npm install -g @angular/cli</code></p></li><li><p>初始化目录</p><p> <code>ng new electron-base -sd src/renderer -si -sg -st --routing true --styles scss</code> </p></li><li><p>修改<code>.angular-cli.json</code></p> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"apps": [&#123;</span><br><span class="line">  "root": "src/renderer",// 源文件目录</span><br><span class="line">  "outDir": "out/renderer", // 输出目录</span><br><span class="line">  "baseHref": "./", // 解决打包后无法加载文件</span><br><span class="line">  ...</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></li></ol><h3 id="如何在开发过程中进行代码热更新"><a href="#如何在开发过程中进行代码热更新" class="headerlink" title="如何在开发过程中进行代码热更新"></a>如何在开发过程中进行代码热更新</h3><p>前端开发中, 我们可以使用<code>webpack</code>享受到自动刷新、热更新等方便的功能， 那么在Electron的开发过程我们如何享受的到这些功能了？这里我们只需要简单的修改下<code>main.js</code>文件即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isDev</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> process.env[<span class="string">'NODE_ENV'</span>] === <span class="string">'development'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWindow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    win = <span class="keyword">new</span> BrowserWindow(&#123; <span class="attr">width</span>: <span class="number">800</span>, <span class="attr">height</span>: <span class="number">600</span> &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isDev()) &#123;</span><br><span class="line">        <span class="comment">// 这里的url换成你所使用框架开发时的url</span></span><br><span class="line">        win.loadURL(<span class="string">'http://127.0.0.1:4200'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        win.loadURL(url.format(&#123;</span><br><span class="line">            pathname: path.join(__dirname, <span class="string">'../renderer/index.html'</span>),</span><br><span class="line">            protocol: <span class="string">'file:'</span>,</span><br><span class="line">            slashes: <span class="literal">true</span></span><br><span class="line">        &#125;))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open the DevTools.</span></span><br><span class="line">    win.webContents.openDevTools()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Emitted when the window is closed.</span></span><br><span class="line">    win.on(<span class="string">'closed'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// Dereference the window object, usually you would store windows</span></span><br><span class="line">        <span class="comment">// in an array if your app supports multi windows, this is the time</span></span><br><span class="line">        <span class="comment">// when you should delete the corresponding element.</span></span><br><span class="line">        win = <span class="literal">null</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开发时我们还是按照以前的方式启动一个<code>webpcak</code>服务器进行开发, Electron通过<code>HTTP</code>协议打开页面, 这样我们依旧可以享受到代码热更新等功能.</p><p>通过设置环境变量<code>NODE_ENV</code>来区分开发和生成环境, 在<code>package.json</code>中添加两个命令来方便开发</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "ng": "ng", // angular alias</span><br><span class="line">  "start": "NODE_EBV=production ./node_modules/.bin/electron .", // 添加环境变量</span><br><span class="line">  "dev:renderer": "ng serve" // 启动渲染线程开发服务器</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="打包渲染线程代码"><a href="#打包渲染线程代码" class="headerlink" title="打包渲染线程代码"></a>打包渲染线程代码</h3><p>开发完成后我们需要将前端的代码进行代码打包, 一个好的习惯是将代码的打包目录放置在项目的根目录中, 这里我将前端的打包目录设置在<code>out/renderer</code>中</p><p>Angular项目只需要修改<code>.angular-cli.json</code>中的<code>outDir</code>字段, 其他的框架可以自行修改. </p><p>在<code>package.json</code>中添加打包命令</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  ....</span><br><span class="line">  "build:renderer": "ng buidl --prod" // 打包渲染线程代码</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="开发主线程"><a href="#开发主线程" class="headerlink" title="开发主线程"></a>开发主线程</h2><p>主线程的开发如<code>Node</code>程序的开发没有多大的区别, 这里就不多赘述.</p><p>虽然<code>Node</code>对<code>ES6</code>的支持已经很完善了, 但更新的标准的支持就不怎么好, 这里我们可以使用<code>Babel</code>之类的工具进行来使用最新的语法.</p><p>这里我推荐使用<code>Typescript</code>, 优点主要有三个:</p><ol><li>静态检查, 毕竟是主线程的代码, 有点错误可就是程序直接崩溃的节奏</li><li>自动提示, 这个不解释</li><li>编译方便, 比起<code>Babel</code>的配置文件, <code>Typescript</code>的配置要简单的多</li></ol><h3 id="使用Typescript-不使用的可以跳过"><a href="#使用Typescript-不使用的可以跳过" class="headerlink" title="使用Typescript (不使用的可以跳过)"></a>使用Typescript (不使用的可以跳过)</h3><ol><li><p>安装<code>Typescript</code></p><p>运行<code>npm install typescript -D</code></p></li><li><p>添加配置文件, 在<code>src</code>目录下添加<code>tsconfig.main.json</code>文件</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">        "outDir": "../out",  // 输出目录, 同渲染线程放在一起</span><br><span class="line">        "sourceMap": true, // 调试时需要</span><br><span class="line">        "moduleResolution": "node",</span><br><span class="line">        "emitDecoratorMetadata": true,</span><br><span class="line">        "experimentalDecorators": true,</span><br><span class="line">        "target": "es6",     // 输出代码版本, 由于在Node中运行, es6没问题</span><br><span class="line">        "module": "commonjs",// module 处理方式</span><br><span class="line">        "typeRoots": [// .d.ts 目录</span><br><span class="line">            <span class="string">"../node_modules/@types"</span></span><br><span class="line">        ],</span><br><span class="line">        "lib": [// 可选, 添加新的语法支持</span><br><span class="line">            <span class="string">"es2017"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">   "exclude": [// 排除渲染线程目录</span><br><span class="line">        <span class="string">"renderer"</span></span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>package.json</code>中添加开发和打包命令</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">...</span><br><span class="line">  "dev:main": "tsc -p ./src/tsconfig.main.json -w", // 开发</span><br><span class="line">  "build:main": "tsc -p ./src/tsconfig.main.json"   // 打包</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="主线程调试-使用的编辑器是vscode"><a href="#主线程调试-使用的编辑器是vscode" class="headerlink" title="主线程调试 (使用的编辑器是vscode)"></a>主线程调试 (使用的编辑器是vscode)</h3><ol><li><p>添加启动配置文件, 项目根目录新建<code>.vscode</code>文件夹,在其中新建<code>launch.json</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // Use IntelliSense to learn about possible Node.js debug attributes.</span><br><span class="line">    // Hover to view descriptions of existing attributes.</span><br><span class="line">    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span><br><span class="line">    "version": "0.2.0",</span><br><span class="line">    "configurations": [&#123;</span><br><span class="line">        "type": "node",</span><br><span class="line">        "request": "launch",</span><br><span class="line">        "name": "Launch Program",</span><br><span class="line">        "cwd": "$&#123;workspaceRoot&#125;",</span><br><span class="line">        "runtimeExecutable": "$&#123;workspaceRoot&#125;/node_modules/.bin/electron",</span><br><span class="line">        "program": "$&#123;workspaceRoot&#125;/src/main/main.ts", // 你的主文件</span><br><span class="line">        "sourceMaps": true,</span><br><span class="line">        "outFiles": [</span><br><span class="line">            "$&#123;workspaceRoot&#125;/out/**/*.js"// 你的输出文件目录</span><br><span class="line">        ],</span><br><span class="line">        "env": &#123;</span><br><span class="line">            "NODE_ENV": "development"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用组合键<code>ctrl + f5</code>启动程序</p></li><li><p>在文件中添加断点进行调试</p></li></ol><h3 id="主线程开启自动刷新-可选"><a href="#主线程开启自动刷新-可选" class="headerlink" title="主线程开启自动刷新 (可选)"></a>主线程开启自动刷新 (可选)</h3><p>我们的渲染线程可以做到代码变更后自动刷新页面, 在主线程的开发中我们可以使用 <a href="https://github.com/remy/nodemon" target="_blank" rel="noopener">nodemon</a> 来实现同样的功能</p><ol><li><p>安装<code>nodemon</code></p><p><code>npm install nodemon -D</code></p></li><li><p>修改启动命令</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">"start": "nodemon --watch src/main --watch src/shared --exec './node_modules/.bin/electron' ./out/main/main.js"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>以后开发时只需要运行<code>npm start</code>就可做到主线程的自动刷新</p><h3 id="打包主线程"><a href="#打包主线程" class="headerlink" title="打包主线程"></a>打包主线程</h3><p>主线程的开发过程我们可能会使用其他的构建工具, 这里我们同渲染线程一样, 将主线程的打包文件放在<code>out</code>目录中, 至此打包目录的结构应当如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">out</span><br><span class="line">├── main - 主线程打包文件位置</span><br><span class="line">│   └── main.js - 入口文件</span><br><span class="line">├── renderer - 渲染线程打包位置</span><br><span class="line">│   ├── .... </span><br><span class="line">│   └── index.html - 入口页面</span><br><span class="line">└── shared - 公用文件</span><br><span class="line">    └── utils.js</span><br></pre></td></tr></table></figure><h2 id="打包和发布"><a href="#打包和发布" class="headerlink" title="打包和发布"></a>打包和发布</h2><p><a href="https://github.com/electron-userland/electron-builder" target="_blank" rel="noopener">electron-builder</a> 可以将我们的程序打包成可执行文件, 它的配置信息发在<code>package.json</code>中</p><p>这里配置的是<code>Mac</code>的打包信息, 具体的可以自行查阅文档</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "main": "out/main/main.js", // 入口文件</span><br><span class="line">  "scripts": &#123;</span><br><span class="line">...</span><br><span class="line">    "pack": "electron-builder -m --dir", // 简单打包软件, 用于测试</span><br><span class="line">    "dist": "electron-builder -m",     // 正式打包软件</span><br><span class="line">    "build": "npm run build:renderer &amp;&amp; npm run build:main &amp;&amp; npm run dist" // 打包软件</span><br><span class="line">  &#125;,</span><br><span class="line">  "build": &#123;</span><br><span class="line">    "appId": "com.lleohao.sample", // 自行修改 </span><br><span class="line">    "mac": &#123;</span><br><span class="line">      "category": "public.app-category.productivity" // 自行修改</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行<code>npm build</code>即可打包软件</p><h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><ol><li>运行<code>npm run dev:renderer</code>启动渲染线程开发</li><li>运行<code>npm run dev:main</code>启动主线程开发</li><li>运行<code>npm start</code>打开<code>Electron</code>程序</li><li>运行<code>npm build</code>打包程序</li></ol><p>示例项目地址 <a href="https://github.com/lleohao/electron-base" target="_blank" rel="noopener">https://github.com/lleohao/electron-base</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这个项目结构是我在编写  &lt;a href=&quot;https://github.com/lleohao/qiniu-upload&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;基于Electron 和 Angular 的七牛文件上传App&lt;/a&gt;  总结出来的&lt;/p&gt;
&lt;p&gt;本文主要介绍如何从零开始搭建高效的Electron开发环境, 主要内容如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过合理的目录划分来组织代码&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;npm script&lt;/code&gt;简化开发&lt;/li&gt;
&lt;li&gt;如何在渲染进程开发时使用热更新&lt;/li&gt;
&lt;li&gt;如何在主进程开发时使用自动重启&lt;/li&gt;
&lt;li&gt;如何在主进程开发时使用&lt;code&gt;Typescript&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如何打包和发布软件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;示例项目地址 &lt;a href=&quot;https://github.com/lleohao/electron-base&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/lleohao/electron-base&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;h2 id=&quot;目录结构划分&quot;&gt;&lt;a href=&quot;#目录结构划分&quot; class=&quot;headerlink&quot; title=&quot;目录结构划分&quot;&gt;&lt;/a&gt;目录结构划分&lt;/h2&gt;&lt;h3 id=&quot;初始化目录&quot;&gt;&lt;a href=&quot;#初始化目录&quot; class=&quot;headerlink&quot; title=&quot;初始化目录&quot;&gt;&lt;/a&gt;初始化目录&lt;/h3&gt;&lt;p&gt;首先按照常规的方法新建一个项目文件夹(这里我的示例文件夹叫做&lt;code&gt;electron-base&lt;/code&gt;， 然后使用&lt;code&gt;npm init&lt;/code&gt;初始化目录。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="指南" scheme="https://lleohao.github.io/tags/%E6%8C%87%E5%8D%97/"/>
    
      <category term="Electron" scheme="https://lleohao.github.io/tags/Electron/"/>
    
      <category term="Angular" scheme="https://lleohao.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>一篇文章解决跨域</title>
    <link href="https://lleohao.github.io/2017/08/12/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F/"/>
    <id>https://lleohao.github.io/2017/08/12/一篇文章解决跨域/</id>
    <published>2017-08-12T07:13:35.000Z</published>
    <updated>2020-11-24T06:07:16.912Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址 <a href="https://www.html5rocks.com/en/tutorials/cors/" target="_blank" rel="noopener">Using CORS</a></p><p>部分内容我精简了部分内容, 如果想看全部可以去上面的原文地址查看</p><p>同时也附上<a href="https://mubu.com/doc/1Mdo8geHR8" target="_blank" rel="noopener">脑图</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="http://www.w3.org/TR/cors/" target="_blank" rel="noopener">Cross-Origin Resource Sharing</a>(CORS) 是W3C为浏览器制定的可以跨域通信的规范. 通过使用 XMLHttpRequest 对象, CORS可以让开发者方便的进行跨域通信, 就像在使用同域通信一样.</p><p>CORS的使用十分简单. 想象一下有一个网站 a.com 想要获取另一个网站 b.com 的数据. 但由于浏览器的<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="noopener">同源策略</a>, 这样的请求将会被禁止. 这时我们可以使用CORS, 通过添加一些特殊的请求\响应头, 可以让 a.com 访问 b.com 的数据.</p><a id="more"></a><p>通过上面的例子我们可以看出, CORS的支持需要客户端和服务器同时支持才行. 幸运的是, 如果你是一名客户端的开发人员(如前端工程师), 绝大多数的技术细节都会被隐藏掉.</p><p>这篇文章将讲述客户端如何发送一个跨域请求, 而服务器又将如何去处理和支持跨域请求.</p><h2 id="发送一个跨域请求"><a href="#发送一个跨域请求" class="headerlink" title="发送一个跨域请求"></a>发送一个跨域请求</h2><p>时至今日, 发送一个XMLHttprequest请求已经是一个简单的事情, 这里我不在过多赘述.</p><p>根据浏览器的同源策略, 当请求的地址与来源地址的协议\域名\端口中的任一值不相同时, 均视为是一个跨域的请求.</p><h3 id="XMLHttprequest-的-withCredentials-属性"><a href="#XMLHttprequest-的-withCredentials-属性" class="headerlink" title="XMLHttprequest 的 withCredentials 属性"></a>XMLHttprequest 的 withCredentials 属性</h3><p>跨域请求通常不会携带cookies信息. 为了能让跨域请求带上cookies, 你需要将做如下设置:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>为了能让这个属性正常工作, 你还需要在服务器端在响应是带上<code>Access-Control-Allow-Credentials</code> , 同时它的值必须为true. 更多的内容可以看<a href="#处理一个非简单请求">服务器设置</a>的那一部分.</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Credentials</span>: true</span><br></pre></td></tr></table></figure><p>设置withCredentials为true后, 在于服务器进行通信时会携带这个域名下的所有cookies, 同时服务器也可以在它的于域名下设置cookies. <strong>但值得注意的是, 这些cookies仍然遵守浏览器的同源策略, 你无法通过javascript访问这个域名下的cookies, 它只被这个域名的服务器控制.</strong></p><h2 id="为服务器增加跨域请求的支持"><a href="#为服务器增加跨域请求的支持" class="headerlink" title="为服务器增加跨域请求的支持"></a>为服务器增加跨域请求的支持</h2><p>大部分跨域请求的重要操作实在浏览器和服务器之间进行的. 浏览器在跨域请求期间会代表客户端在请求上增加行的请求头, 有的时候还会增加新的请求. 这些操作对于开发者来说是透明, 但是这些请求仍然可以被抓包工具捕获.</p><p><img src="./cors_flow.png" alt="跨域请求"></p><p>浏览器的开发者来实现浏览器端的跨域请求细节, 这节内容来介绍如何配置服务器来支持跨域请求.</p><h3 id="跨域请求的分类"><a href="#跨域请求的分类" class="headerlink" title="跨域请求的分类"></a>跨域请求的分类</h3><p>通常将跨越请求分为”简单请求”和”非简单请求”两类.</p><p>简单请求遵循以下的规则</p><p><img src="./simple_http_request.png" alt="简单请求"></p><p>首先它的请求方式只能是GET, POST, PUT</p><p>同时的它的请求头部只能包含上面的那几个类型, 值的注意的是<code>Content-Type</code>只能是罗列出的三种(正好是form的entryType的三个值).</p><p>对于简单请求, 浏览器可以自行解决其中的跨域问题. 例如我们熟知的一个跨域通信的解决方式<code>JSON-P</code>就是利用GET发送一个简单请求来规避跨域的问题.HTML中的表单提交也不需要处理跨域问题.</p><p>任何不符合上述条件的请求都算作非简单请求, 浏览器在处理非简单的跨域请求时会与服务器进行额外的通信(称之为预检请求), 将在下面介绍.</p><h3 id="处理简单请求"><a href="#处理简单请求" class="headerlink" title="处理简单请求"></a>处理简单请求</h3><blockquote><p>通过这个<a href="https://github.com/lleohao/cors-demo" target="_blank" rel="noopener">cors-demo</a>我们可以方便的查看浏览器与服务器之间的同信.</p></blockquote><p>当浏览器发送一个简单请求时, 我们打开浏览器的Network面板可以看到一个如下的请求(删除部分内容)</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/get</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: localhost:5051</span><br><span class="line"><span class="attribute">Origin</span>: http://localhost:8080</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0 ....</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate, br</span><br><span class="line"><span class="attribute">Accept-Language</span>: zh-CN,en;q=0.8,zh;q=0.6,ja;q=0.4,zh-TW;q=0.2</span><br></pre></td></tr></table></figure><p>我们需要注意的一点是, <strong>所有的跨域请求(无论简单或者非简单)总会包含一个<code>Origin</code>的请求头部, 这个属性的值由浏览器添加, 而且不受用户控制. 它的值由协议(如: http), 域名(如: a.om)和端口(只有它不是默认值时才包含, 如80端口)组成, 说明请求的来源.</strong></p><p>包含<code>Origin</code>的请求不一定是跨域请求, 但是跨域请求一定包含<code>Origin</code>. 一些同源的请求同样也会包含<code>Origin</code>请求头.例如, Firefox浏览器不会在同源的请求中添加<code>Origin</code>, 但是Chrome和Safari会在同源的POST/PUT/DELETE请求中添加<code>Origin</code>请求头(但是同源的GET不会添加).</p><p>浏览器会忽略掉同源请求中的的CORS响应中的设置.</p><p>然后我们来看一个有效的跨域请求响应</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span>: http://localhost:8080</span><br><span class="line"><span class="attribute">Access-Control-Allow-Credentials</span>: true</span><br><span class="line"><span class="attribute">Access-Control-Expose-Headers</span>: FooBar</span><br><span class="line"><span class="attribute">Content-Type</span>: text/html; charset=utf-8</span><br></pre></td></tr></table></figure><p>所有与跨域请求相关的HTTP头部都以<code>Access-Control-</code>开始, 下面是它们的详细信息</p><ol><li><p>Access-Control-Allow-Origin (必选)</p><p>所有有效的跨域响应都必须包含这个请求头, 没有的话会导致跨域请求失败. 它的值可以是请求中的<code>Origin</code>的值, 也可以设置为<code>*</code>来表示可以响应所有来源的请求.</p></li><li><p>Access-Control-Allow-Credentials (可选)</p><p>默认情况下跨域请求不会携带cookies信息. 如果需要请求携带cookies信息, 则需要将这个值设置为<code>true</code>, 如果不需要就不要设置这个值, <strong>而不是将它设置为<code>false</code></strong>.</p><p>这个请求头需要与 [withCredentials](#XMLHttprequest 的 withCredentials 属性) 配合使用. 只有两个值都设置为<code>true</code>的时候才能够在请求中携带cookies信息. 当<code>withCredentials</code>设置为<code>true</code>, 而响应中不包含<code>Access-Control-Allow-Credentials</code>时, 请求会发生错误.</p></li><li><p>Access-Control-Expose-Headers (可选)</p><p>XMLHttpRequest2对象上的<code>getResponseHeader()</code>方法可以让你获取到响应中头部信息, 但在跨域请求中,你只能获取到以下信息</p><ul><li>Cache-Control</li><li>Content-Language</li><li>Content-Type</li><li>Expires</li><li>Last-Modified</li><li>Pragma</li></ul><p>如果你希望客户端能过获取其他的头部信息, 可以设置这个值.</p></li></ol><h3 id="处理一个非简单请求"><a href="#处理一个非简单请求" class="headerlink" title="处理一个非简单请求"></a>处理一个非简单请求</h3><p>对与开发者来说, 发送一个跨域的非简单请求跟发送一个同域请求没什么区别.但事实上浏览器会发送两个请求, 第一个请求(成为预检请求)会像服务器确定是否接受这个跨域请求, 第二个才是真正的发出请求. 浏览器自动的处理这两个请求, 同时预检请求也是可以被缓存的, 而不用每次请求都需要发送预检请求.</p><p>下面是一个预检请求</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">OPTIONS</span> <span class="string">/cors/post</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: localhost:5051</span><br><span class="line"><span class="attribute">Access-Control-Request-Method</span>: POST</span><br><span class="line"><span class="attribute">Access-Control-Request-Headers</span>: content-type</span><br><span class="line"><span class="attribute">Origin</span>: http://localhost:8080</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0 ...</span><br><span class="line"><span class="attribute">DNT</span>: 1</span><br><span class="line"><span class="attribute">Referer</span>: http://localhost:8080/</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate, br</span><br><span class="line"><span class="attribute">Accept-Language</span>: zh-CN,en;q=0.8,zh;q=0.6,ja;q=0.4,zh-TW;q=0.2</span><br></pre></td></tr></table></figure><p>如同简单跨域请求一样, 在预检请求中也包含了<code>Origin</code>请求头, 同时这个请求的方式<code>OPTIONS</code>(所以你必须确定你的服务器能够正常的处理这中请求). 它同时也包含了其他的请求头.</p><ol><li><p>Access-Control-Request-Method</p><p>这个请求头的值就是正式请求的请求方式, 上面的那个例子就是POST</p></li><li><p>Access-Control-Request-Headers</p><p>它的值是一个由逗号分隔的正式请求中请求头的列表.</p></li></ol><p>预检请求是在实际的请求发出前先向服务器确认是否能够处理这个请求. 服务器应该检查上边两个请求头的值, 来判断这个请求是否有效.</p><p>如果服务器确认这个请求有效, 那么它会做出如下的响应</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Access-Control-Allow-Origin</span>: http://localhost:8080</span><br><span class="line"><span class="attribute">Access-Control-Allow-Headers</span>: Content-Type</span><br><span class="line"><span class="attribute">Access-Control-Allow-Methods</span>: GET, POST, PUT, DELETE</span><br><span class="line"><span class="attribute">Content-Type</span>: text/html</span><br><span class="line"><span class="attribute">Date</span>: Sat, 12 Aug 2017 13:46:08 GMT</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: chunked</span><br></pre></td></tr></table></figure><ol><li><p>Access-Control-Allow-Origin (必选)</p><p>如同简单跨域请求一样, 预检请求的响应也必须包含这个值</p></li><li><p>Access-Control-Allow-Methods (必选)</p><p>由逗号分隔的HTTP请求方式, 在其中的值表示服务能够接受这中请求方式的跨域请求.</p><p>值得注意的是虽然预检请求只是针对单个请求方式进行检测, 但是你仍可以返回一个你所支持的请求方式列表.这样做的好处是方便对预检请求进行缓存.</p></li><li><p>Access-Control-Allow-Headers (当预检请求中包含Access-Control-Request-Headers时是必须的)</p><p>由逗号分隔的支持的请求头部列表, 与<code>Access-Control-Allow-Methods</code>类似, 虽然预检请求中只有很少的一部分请求头, 但是你仍然可以返回所有你支持的列表, 原因也是为了缓存.</p></li><li><p>Access-Control-Allow-Credentials (可选)</p><p>同简单请求</p></li><li><p>Access-Control-Max-Age (可选)</p><p>在每个请求前面都发送一个预检请求是很浪费资源的, 这个值允许你设置预检请求的缓存时间, 单位是秒.</p></li></ol><p>一旦预检请求通过服务器的检查, 那么浏览器会随后发送实际的请求. 实际请求的处理与简单请求一样.</p><p>如果服务器想要拒绝一个跨域请求, 那么他可以直接回复一个简单的响应(如 HTTP 200), 但在响应头中不要包含任何与CORS相关的响应头设置. 服务器也可能会因为预检请求不合法而拒绝这个请求. 如果预检请求中不包含正确的CORS头部设置, 它就不会发送实际的请求.</p><p>当跨域请求发生错时, 浏览器会调用<code>onerror</code>事件, 同时会在控制台打印相关的错误信息.</p><p><img src="./cors_error.png" alt="cors request error"></p><p>最后附上一个服务器端处理跨域请求的流程图</p><p><img src="./cors_server_flowchart.png" alt="服务器处理跨域请求流程图"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文地址 &lt;a href=&quot;https://www.html5rocks.com/en/tutorials/cors/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Using CORS&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;部分内容我精简了部分内容, 如果想看全部可以去上面的原文地址查看&lt;/p&gt;
&lt;p&gt;同时也附上&lt;a href=&quot;https://mubu.com/doc/1Mdo8geHR8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;脑图&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://www.w3.org/TR/cors/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cross-Origin Resource Sharing&lt;/a&gt;(CORS) 是W3C为浏览器制定的可以跨域通信的规范. 通过使用 XMLHttpRequest 对象, CORS可以让开发者方便的进行跨域通信, 就像在使用同域通信一样.&lt;/p&gt;&lt;p&gt;CORS的使用十分简单. 想象一下有一个网站 a.com 想要获取另一个网站 b.com 的数据. 但由于浏览器的&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;同源策略&lt;/a&gt;, 这样的请求将会被禁止. 这时我们可以使用CORS, 通过添加一些特殊的请求\响应头, 可以让 a.com 访问 b.com 的数据.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="前端" scheme="https://lleohao.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="后端" scheme="https://lleohao.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="跨域" scheme="https://lleohao.github.io/tags/%E8%B7%A8%E5%9F%9F/"/>
    
      <category term="CORS" scheme="https://lleohao.github.io/tags/CORS/"/>
    
  </entry>
  
  <entry>
    <title>解决js键盘事件在处理小键盘时的问题</title>
    <link href="https://lleohao.github.io/2017/01/12/%E8%A7%A3%E5%86%B3js%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6%E5%9C%A8%E5%A4%84%E7%90%86%E5%B0%8F%E9%94%AE%E7%9B%98%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://lleohao.github.io/2017/01/12/解决js键盘事件在处理小键盘时的问题/</id>
    <published>2017-01-12T03:56:15.000Z</published>
    <updated>2020-11-24T06:07:16.916Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>先来看一个简单问题，在控制台输入下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试平台 win10 chrome 55.0.2883.87</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'keydown'</span>, (e) =&gt; &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(e.which))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后在页面上按小键盘上面的<code>1</code>键，你觉得会打印出什么？</p><blockquote><p>结果为 ‘a’，why ?</p></blockquote><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>我们先看看MDN中是怎么解释 <code>KeyboardEvent</code>事件中的返回值</p><blockquote><p><code>keyCode</code>: This is usually the decimal ASCII.</p><p><code>which</code>:     this is usually the same as <code>keyCode</code>.</p><p>详细信息可以看这个 <a href="https://developer.mozilla.org/en-US/docs/Web/Events/keydown" target="_blank" rel="noopener">keydown</a></p></blockquote><a id="more"></a><p>可以看到我们拿到的返回值大多数情况下是键盘按键对应的<code>ASCII</code>码，具体的<a href="http://wenku.baidu.com/view/39cbd36f1eb91a37f1115c88.html?from=search" target="_blank" rel="noopener">对照表</a></p><p>然后再看下<code>String.fromCharCode()</code>接受的参数是什么</p><blockquote><p>The static <strong>String.fromCharCode()</strong> method returns a string created by using the specified sequence of <em>Unicode</em> values.</p></blockquote><p><code>String.fromCharCode()</code>接受的是一个<code>Unicode</code>编码，正是由于这个原因才导致我们解析出来的数据不正确。</p><p>关于<code>Unicode</code>编码与<code>ASCII</code>编码的相关知识可以看看<a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">这篇文章</a></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li><p>使用<code>KeyboardEvent</code>事件中的<code>key</code>值，这种方式最直接，但是不支持<code>Safari</code>，如果不需要兼容苹果的设备这是最好的方式。</p><p><img src="charCode.png" alt></p></li><li><p>可以选择监听<code>keypress</code>事件，这个事件对象有个独有的属性值<code>charCode</code>，返回的是<code>Unicode</code>编码。这样的话用<code>String.fromCharCode()</code>可以直接使用。</p><p><img src="key.png" alt></p></li><li><p>使用第三方的库 <a href="https://github.com/timoxley/keycode" target="_blank" rel="noopener">keycode</a></p></li></ol><h2 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h2><p>几个小tips</p><ol><li><code>keypress</code>、<code>input</code>事件不会响应辅助按键，如：<code>ctrl</code> <code>alt</code> <code>shift</code> 等，某些情况下会很方便。</li><li><code>keypress</code>、<code>input</code>事件不响应中文输入法</li><li>中文输入法对应情况下<code>keydown</code>的<code>which</code>值为<code>299</code>，<code>keyup</code>对应的值是正确的</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;先来看一个简单问题，在控制台输入下面的代码：&lt;/p&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 测试平台 win10 chrome 55.0.2883.87&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.addEventListener(&lt;span class=&quot;string&quot;&gt;&#39;keydown&#39;&lt;/span&gt;, (e) =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;built_in&quot;&gt;String&lt;/span&gt;.fromCharCode(e.which))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;然后在页面上按小键盘上面的&lt;code&gt;1&lt;/code&gt;键，你觉得会打印出什么？&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;结果为 ‘a’，why ?&lt;/p&gt;
&lt;/blockquote&gt;&lt;h2 id=&quot;问题原因&quot;&gt;&lt;a href=&quot;#问题原因&quot; class=&quot;headerlink&quot; title=&quot;问题原因&quot;&gt;&lt;/a&gt;问题原因&lt;/h2&gt;&lt;p&gt;我们先看看MDN中是怎么解释 &lt;code&gt;KeyboardEvent&lt;/code&gt;事件中的返回值&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;keyCode&lt;/code&gt;: This is usually the decimal ASCII.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;which&lt;/code&gt;:     this is usually the same as &lt;code&gt;keyCode&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;详细信息可以看这个 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/keydown&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;keydown&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="前端" scheme="https://lleohao.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="https://lleohao.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
